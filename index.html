<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="Lucid Dreamer â€“ æ¸…é†’å¤¢èª˜ç™¼å·¥å…·">
<title>Lucid Dreamer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg-deep: #0a0a1a;
  --bg-card: rgba(255, 255, 255, 0.04);
  --border-glass: rgba(255, 255, 255, 0.08);
  --accent: #7c5cff;
  --accent-glow: rgba(124, 92, 255, 0.35);
  --accent-soft: #a78bfa;
  --text: #e4e4f0;
  --text-dim: #8888a8;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --radius: 16px;
  --font: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
}

html, body {
  height: 100%;
  font-family: var(--font);
  background: var(--bg-deep);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  overflow-x: hidden;
}

body {
  background:
    radial-gradient(ellipse 80% 60% at 50% -10%, rgba(124, 92, 255, 0.15), transparent),
    radial-gradient(ellipse 50% 40% at 80% 90%, rgba(99, 102, 241, 0.1), transparent),
    var(--bg-deep);
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1.5rem 1rem 3rem;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
h1 {
  font-size: 1.75rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, #c4b5fd, #818cf8, #7c5cff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 0.25rem;
}
.subtitle { font-size: 0.8rem; color: var(--text-dim); font-weight: 300; margin-bottom: 1.5rem; }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Glass Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card {
  width: 100%;
  max-width: 420px;
  background: var(--bg-card);
  border: 1px solid var(--border-glass);
  border-radius: var(--radius);
  backdrop-filter: blur(24px);
  -webkit-backdrop-filter: blur(24px);
  padding: 1.5rem;
  margin-bottom: 1rem;
  transition: border-color 0.3s;
}
.card:hover { border-color: rgba(255,255,255,0.12); }

.card-title {
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-dim);
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.card-title::before {
  content: '';
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent-glow);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.control-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.85rem;
}
.control-row:last-child { margin-bottom: 0; }

.control-label {
  font-size: 0.82rem;
  font-weight: 400;
  color: var(--text);
}
.control-label small {
  display: block;
  font-size: 0.68rem;
  color: var(--text-dim);
  font-weight: 300;
  margin-top: 2px;
}

input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 130px;
  height: 4px;
  border-radius: 2px;
  background: rgba(255,255,255,0.1);
  outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--accent);
  box-shadow: 0 0 10px var(--accent-glow);
  cursor: pointer;
}
.range-value {
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--accent-soft);
  min-width: 3rem;
  text-align: right;
  font-variant-numeric: tabular-nums;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Status Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.status-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.75rem;
}
.status-item {
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-glass);
  border-radius: 12px;
  padding: 0.75rem;
  text-align: center;
}
.status-item.wide { grid-column: 1 / -1; }
.status-label {
  font-size: 0.65rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-dim);
  margin-bottom: 0.3rem;
}
.status-value {
  font-size: 1.4rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: var(--text);
}
.status-value.countdown {
  font-size: 2rem;
  background: linear-gradient(135deg, #c4b5fd, #7c5cff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Big Button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.start-btn {
  width: 100%;
  max-width: 420px;
  padding: 1rem;
  border: none;
  border-radius: var(--radius);
  font-family: var(--font);
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.04em;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  margin-top: 0.5rem;
}
.start-btn.ready {
  background: linear-gradient(135deg, #7c5cff, #6366f1);
  color: #fff;
  box-shadow: 0 4px 24px var(--accent-glow);
}
.start-btn.ready:active {
  transform: scale(0.97);
  box-shadow: 0 2px 12px var(--accent-glow);
}
.start-btn.running {
  background: linear-gradient(135deg, #ef4444, #dc2626);
  color: #fff;
  box-shadow: 0 4px 24px rgba(239, 68, 68, 0.3);
}
.start-btn.running:active { transform: scale(0.97); }

/* Pulse animation when active */
@keyframes pulse-ring {
  0% { transform: scale(1); opacity: 0.4; }
  100% { transform: scale(2.5); opacity: 0; }
}
.start-btn.running::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: var(--radius);
  border: 2px solid rgba(239, 68, 68, 0.5);
  animation: pulse-ring 2s ease-out infinite;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.log-area {
  width: 100%;
  max-width: 420px;
  max-height: 120px;
  overflow-y: auto;
  margin-top: 0.75rem;
  padding: 0.75rem;
  background: rgba(0,0,0,0.3);
  border: 1px solid var(--border-glass);
  border-radius: 12px;
  font-size: 0.7rem;
  color: var(--text-dim);
  line-height: 1.6;
  font-variant-numeric: tabular-nums;
}
.log-area .log-entry { margin-bottom: 2px; }
.log-area .log-entry.played { color: var(--success); }
.log-area .log-entry.skipped { color: var(--warning); }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Debug Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.debug-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 0.85rem;
  padding-top: 0.85rem;
  border-top: 1px solid var(--border-glass);
}
.debug-label {
  font-size: 0.82rem;
  font-weight: 400;
  color: var(--warning);
}
.debug-label small {
  display: block;
  font-size: 0.68rem;
  color: var(--text-dim);
  font-weight: 300;
  margin-top: 2px;
}
.toggle {
  position: relative;
  width: 44px;
  height: 24px;
  cursor: pointer;
}
.toggle input { opacity: 0; width: 0; height: 0; }
.toggle .slider {
  position: absolute;
  inset: 0;
  background: rgba(255,255,255,0.1);
  border-radius: 12px;
  transition: background 0.3s;
}
.toggle .slider::before {
  content: '';
  position: absolute;
  left: 3px; top: 3px;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: #fff;
  transition: transform 0.3s;
}
.toggle input:checked + .slider {
  background: var(--warning);
}
.toggle input:checked + .slider::before {
  transform: translateX(20px);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scrollbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.footer {
  margin-top: auto;
  padding-top: 1.5rem;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.15);
  text-align: center;
}
</style>
</head>
<body>

<h1>ğŸŒ™ Lucid Dreamer</h1>
<p class="subtitle">æ¸…é†’å¤¢èª˜ç™¼å·¥å…· â€” PoC</p>

<!-- â”€â”€â”€ Settings â”€â”€â”€ -->
<div class="card" id="settings-card">
  <div class="card-title">è¨­å®š</div>

  <div class="control-row">
    <div class="control-label">å…¥ç¡ç·©è¡<small>é¦–æ¬¡è§¸ç™¼å‰çš„ç­‰å¾…æ™‚é–“</small></div>
    <input type="range" id="initial-delay" min="1" max="60" value="20" step="1">
    <span class="range-value" id="initial-delay-val">20 min</span>
  </div>

  <div class="control-row">
    <div class="control-label">æœ€å°é–“éš”<small>å¾ªç’°é–“æœ€çŸ­ç­‰å¾…</small></div>
    <input type="range" id="min-interval" min="1" max="30" value="5" step="1">
    <span class="range-value" id="min-interval-val">5 min</span>
  </div>

  <div class="control-row">
    <div class="control-label">æœ€å¤§é–“éš”<small>å¾ªç’°é–“æœ€é•·ç­‰å¾…</small></div>
    <input type="range" id="max-interval" min="2" max="60" value="15" step="1">
    <span class="range-value" id="max-interval-val">15 min</span>
  </div>

  <div class="control-row">
    <div class="control-label">éŸ³é‡ä¸Šé™<small>æ¼¸å¼·æœ€å¤§éŸ³é‡</small></div>
    <input type="range" id="volume-cap" min="5" max="100" value="40" step="5">
    <span class="range-value" id="volume-cap-val">40%</span>
  </div>

  <div class="control-row">
    <div class="control-label">è§¸ç™¼æ©Ÿç‡<small>æ¯æ¬¡å¾ªç’°æ’­æ”¾çš„æ©Ÿç‡</small></div>
    <input type="range" id="probability" min="10" max="100" value="30" step="5">
    <span class="range-value" id="probability-val">30%</span>
  </div>

  <div class="debug-row">
    <div class="debug-label">âš¡ Debug æ¨¡å¼<small>è·³éå»¶é²èˆ‡æ©Ÿç‡ï¼Œé€£çºŒæ’­æ”¾</small></div>
    <label class="toggle">
      <input type="checkbox" id="debug-mode">
      <span class="slider"></span>
    </label>
  </div>
</div>

<!-- â”€â”€â”€ Status â”€â”€â”€ -->
<div class="card">
  <div class="card-title">ç‹€æ…‹</div>
  <div class="status-grid">
    <div class="status-item wide">
      <div class="status-label">å€’æ•¸è¨ˆæ™‚</div>
      <div class="status-value countdown" id="countdown">--:--</div>
    </div>
    <div class="status-item">
      <div class="status-label">ç›®å‰éšæ®µ</div>
      <div class="status-value" id="phase" style="font-size:0.85rem;">å¾…æ©Ÿ</div>
    </div>
    <div class="status-item">
      <div class="status-label">å·²è§¸ç™¼</div>
      <div class="status-value" id="trigger-count">0</div>
    </div>
  </div>
</div>

<!-- â”€â”€â”€ Start Button â”€â”€â”€ -->
<button class="start-btn ready" id="start-btn">â–¶  é–‹å§‹</button>

<!-- â”€â”€â”€ Log â”€â”€â”€ -->
<div class="log-area" id="log-area">
  <div class="log-entry">ç­‰å¾…é–‹å§‹...</div>
</div>

<div class="footer">Lucid Dreamer PoC Â· GitHub Pages Edition</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Lucid Dreamer â€” iOS-optimized lucid dream induction engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(function () {
  'use strict';

  // â”€â”€â”€ DOM refs â”€â”€â”€
  const $ = id => document.getElementById(id);
  const startBtn       = $('start-btn');
  const countdownEl    = $('countdown');
  const phaseEl        = $('phase');
  const triggerCountEl = $('trigger-count');
  const logArea        = $('log-area');
  const settingsCard   = $('settings-card');

  // Sliders
  const sliders = {
    initialDelay: { el: $('initial-delay'), valEl: $('initial-delay-val'), fmt: v => `${v} min` },
    minInterval:  { el: $('min-interval'),  valEl: $('min-interval-val'),  fmt: v => `${v} min` },
    maxInterval:  { el: $('max-interval'),  valEl: $('max-interval-val'),  fmt: v => `${v} min` },
    volumeCap:    { el: $('volume-cap'),    valEl: $('volume-cap-val'),    fmt: v => `${v}%` },
    probability:  { el: $('probability'),   valEl: $('probability-val'),   fmt: v => `${v}%` },
  };

  // Sync slider display
  Object.values(sliders).forEach(s => {
    s.el.addEventListener('input', () => { s.valEl.textContent = s.fmt(s.el.value); });
  });

  // â”€â”€â”€ State â”€â”€â”€
  const debugToggle = $('debug-mode');
  let audioCtx      = null;   // Web Audio context (created on user tap)
  let silentOsc     = null;   // Silent oscillator (Web Audio backup)
  let silentAudio   = null;   // HTML5 <audio> element playing silence.mp3
  let wakePingId    = null;   // Interval ID for periodic wake-up pings
  let fileList      = [];     // Array of filenames from filelist.json
  let isRunning     = false;
  let debugMode     = false;
  let triggerCount  = 0;
  let countdownId   = null;   // requestAnimationFrame / setTimeout id
  let targetTime    = 0;      // Unix ms when current wait ends

  // â”€â”€â”€ Helpers â”€â”€â”€
  function getVal(key) { return Number(sliders[key].el.value); }

  function log(msg, cls = '') {
    const now = new Date();
    const ts = now.toLocaleTimeString('zh-TW', { hour12: false });
    const div = document.createElement('div');
    div.className = 'log-entry' + (cls ? ` ${cls}` : '');
    div.textContent = `[${ts}] ${msg}`;
    logArea.appendChild(div);
    logArea.scrollTop = logArea.scrollHeight;
  }

  function formatTime(ms) {
    if (ms <= 0) return '00:00';
    const totalSec = Math.ceil(ms / 1000);
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  }

  function randomInRange(minMin, maxMin) {
    // Returns ms for a random duration between minMin and maxMin minutes
    const lo = Math.min(minMin, maxMin);
    const hi = Math.max(minMin, maxMin);
    return (lo + Math.random() * (hi - lo)) * 60 * 1000;
  }

  // â”€â”€â”€ Load file list â”€â”€â”€
  async function loadFileList() {
    try {
      const res = await fetch('filelist.json');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      fileList = await res.json();
      log(`å·²è¼‰å…¥ ${fileList.length} å€‹éŸ³è¨Šæª”`);
    } catch (e) {
      log(`âš ï¸ ç„¡æ³•è¼‰å…¥ filelist.json: ${e.message}`);
      fileList = [];
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  iOS Background Persistence â€” Multi-Layer Strategy
  //
  //  iOS Safari aggressively suspends JS when the screen locks.
  //  A single silent oscillator is no longer sufficient on modern iOS.
  //  We use FOUR layers to maximize survival:
  //
  //  Layer 1: HTML5 <audio> element looping a real silence.mp3 file.
  //           iOS treats <audio> playback as a "real" media session
  //           and is far less likely to suspend it vs Web Audio API.
  //
  //  Layer 2: Media Session API â€” registers metadata so the OS
  //           recognizes this page as an active media player (shows
  //           in Control Center / lock screen media controls).
  //
  //  Layer 3: Web Audio API silent oscillator (legacy backup).
  //
  //  Layer 4: Periodic wake-up pings â€” every 5 seconds, forcibly
  //           resume the AudioContext and re-trigger the silent audio
  //           if it was paused by the OS.
  //
  //  CRITICAL: Everything MUST be initiated from a user gesture
  //  (click/touchend) to satisfy iOS autoplay policy.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function createAudioContext() {
    // â”€â”€ Layer 1: HTML5 <audio> element with looping silent MP3 â”€â”€
    // This is the PRIMARY keep-alive mechanism. iOS treats <audio>
    // element playback as a legitimate media session.
    silentAudio = new Audio('audio/silence.mp3');
    silentAudio.loop = true;
    silentAudio.volume = 0.01;  // near-silent but not zero (iOS may optimize away zero)
    silentAudio.setAttribute('playsinline', '');
    silentAudio.play().catch(() => {});

    // â”€â”€ Layer 2: Media Session API â”€â”€
    // Tell the OS we're a media player. This puts us in Control Center
    // and signals iOS not to suspend our audio session.
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: 'Lucid Dreamer',
        artist: 'æ¸…é†’å¤¢èª˜ç™¼ä¸­...',
        album: 'Sleep Session',
      });
      // Handle play/pause from lock screen controls
      navigator.mediaSession.setActionHandler('play', () => {
        silentAudio.play().catch(() => {});
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        // Don't actually pause â€” keep running
        silentAudio.play().catch(() => {});
      });
    }

    // â”€â”€ Layer 3: Web Audio API silent oscillator (backup) â”€â”€
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    silentOsc = audioCtx.createOscillator();
    const silentGain = audioCtx.createGain();
    silentGain.gain.value = 0;
    silentOsc.connect(silentGain);
    silentGain.connect(audioCtx.destination);
    silentOsc.start();

    // â”€â”€ Layer 4: Periodic wake-up pings â”€â”€
    // Every 5 seconds, aggressively re-assert our audio session.
    // If iOS suspended our AudioContext, resume it. If <audio> paused, replay.
    wakePingId = setInterval(() => {
      // Resume AudioContext if suspended
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      // Re-start silent audio if it was paused by the OS
      if (silentAudio && silentAudio.paused) {
        silentAudio.play().catch(() => {});
      }
      // Tiny Web Audio "ping" â€” create a very short buffer and play it
      // This creates audio activity that iOS cannot ignore
      if (audioCtx && audioCtx.state === 'running') {
        const buf = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
        const src = audioCtx.createBufferSource();
        src.buffer = buf;
        const g = audioCtx.createGain();
        g.gain.value = 0;
        src.connect(g);
        g.connect(audioCtx.destination);
        src.start();
      }
    }, 5000);

    // Also resume on visibility change (user unlocks screen)
    document.addEventListener('visibilitychange', () => {
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      if (silentAudio && silentAudio.paused) silentAudio.play().catch(() => {});
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  Audio Playback with Fade-in Ramp (HTML5 <audio> element)
  //
  //  CRITICAL iOS FIX: We use HTML5 <audio> elements for voice track
  //  playback instead of Web Audio API BufferSource. iOS keeps <audio>
  //  elements alive through screen lock, but suspends Web Audio
  //  buffer sources. The fade-in is implemented via a JS-driven
  //  volume ramp using setInterval.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function playRandomTrack() {
    if (!fileList.length) return;

    // Filter out silence.mp3 from random selection
    const playable = fileList.filter(f => f !== 'silence.mp3');
    if (!playable.length) return;

    const file = playable[Math.floor(Math.random() * playable.length)];
    const url = `audio/${file}`;

    return new Promise((resolve) => {
      try {
        const audio = new Audio(url);
        audio.setAttribute('playsinline', '');

        const volumeCap = getVal('volumeCap') / 100;

        if (debugMode) {
          // Debug: instant volume, no fade
          audio.volume = volumeCap;
        } else {
          // Fade-in: ramp from 0 â†’ volumeCap over 2 seconds
          audio.volume = 0;
        }

        audio.play().then(() => {
          // JS-driven fade-in (works on iOS lock screen unlike Web Audio GainNode)
          if (!debugMode) {
            const fadeMs = 2000;
            const steps = 40;  // 40 steps over 2 seconds = 50ms per step
            const stepMs = fadeMs / steps;
            const increment = volumeCap / steps;
            let currentStep = 0;
            const fadeInterval = setInterval(() => {
              currentStep++;
              audio.volume = Math.min(increment * currentStep, volumeCap);
              if (currentStep >= steps) clearInterval(fadeInterval);
            }, stepMs);
          }
        }).catch((e) => {
          log(`âŒ æ’­æ”¾å¤±æ•—: ${e.message}`);
          resolve();
        });

        audio.onended = () => {
          // In debug mode, chain next track immediately
          if (debugMode && isRunning) {
            setTimeout(() => playRandomTrack(), 500);
          }
          resolve();
        };

        audio.onerror = () => {
          log(`âŒ è¼‰å…¥å¤±æ•—: ${file}`);
          resolve();
        };

        triggerCount++;
        triggerCountEl.textContent = triggerCount;
        log(`â–¶ æ’­æ”¾: ${file.slice(0, 8)}...`, 'played');
      } catch (e) {
        log(`âŒ æ’­æ”¾å¤±æ•—: ${e.message}`);
        resolve();
      }
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  Countdown Timer
  //
  //  Uses a 1-second setTimeout loop instead of setInterval for
  //  better iOS compatibility. The countdown compares against a
  //  target timestamp so accumulated drift doesn't matter.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function startCountdown(durationMs, label, onComplete) {
    targetTime = Date.now() + durationMs;
    phaseEl.textContent = label;

    function tick() {
      if (!isRunning) return;
      const remaining = targetTime - Date.now();
      countdownEl.textContent = formatTime(remaining);

      if (remaining <= 0) {
        countdownEl.textContent = '00:00';
        onComplete();
      } else {
        countdownId = setTimeout(tick, 1000);
      }
    }
    tick();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  Main Loop â€” Randomized Scheduler with Probability Gate
  //
  //  After the initial delay, each cycle:
  //    1. Picks a random wait duration within [minInterval, maxInterval]
  //    2. Counts down the wait
  //    3. Rolls a probability check (e.g. 30%)
  //    4. If passed â†’ plays a random track with fade-in
  //    5. Repeats
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function scheduleCycle() {
    if (!isRunning) return;

    const waitMs = randomInRange(getVal('minInterval'), getVal('maxInterval'));
    const waitMin = (waitMs / 60000).toFixed(1);
    log(`â³ ä¸‹æ¬¡å¾ªç’°: ${waitMin} åˆ†é˜å¾Œ`);

    startCountdown(waitMs, 'ç­‰å¾…ä¸­', () => {
      if (!isRunning) return;

      const prob = getVal('probability') / 100;
      const roll = Math.random();

      if (roll < prob) {
        phaseEl.textContent = 'æ’­æ”¾ä¸­';
        playRandomTrack().then(() => {
          // Short pause after playback before next cycle
          setTimeout(() => { if (isRunning) scheduleCycle(); }, 3000);
        });
      } else {
        log(`â­ è·³é (æ©Ÿç‡ ${(roll * 100).toFixed(0)}% > ${getVal('probability')}%)`, 'skipped');
        scheduleCycle();
      }
    });
  }

  function startSession() {
    if (!fileList.length) {
      log('âš ï¸ æ²’æœ‰å¯ç”¨çš„éŸ³è¨Šæª”ï¼Œè«‹å…ˆç”Ÿæˆ filelist.json');
      return;
    }

    isRunning = true;
    debugMode = debugToggle.checked;
    triggerCount = 0;
    triggerCountEl.textContent = '0';

    // Create AudioContext on user tap (iOS autoplay requirement)
    if (!audioCtx) createAudioContext();

    // Lock settings
    settingsCard.style.opacity = '0.5';
    settingsCard.style.pointerEvents = 'none';

    startBtn.textContent = 'â¹  åœæ­¢';
    startBtn.className = 'start-btn running';

    // â”€â”€â”€ Debug mode: skip everything, play immediately back-to-back â”€â”€â”€
    if (debugMode) {
      log('âš¡ Debug æ¨¡å¼ï¼šé€£çºŒéš¨æ©Ÿæ’­æ”¾ï¼Œç„¡å»¶é²');
      phaseEl.textContent = 'Debug';
      countdownEl.textContent = 'âš¡';
      playRandomTrack();
      return;
    }

    const delayMs = getVal('initialDelay') * 60 * 1000;
    log(`ğŸŒ™ é–‹å§‹! å…¥ç¡ç·©è¡: ${getVal('initialDelay')} åˆ†é˜`);

    startCountdown(delayMs, 'å…¥ç¡ç·©è¡', () => {
      log('â° ç·©è¡çµæŸï¼Œé–‹å§‹å¾ªç’°');
      scheduleCycle();
    });
  }

  function stopSession() {
    isRunning = false;
    if (countdownId) { clearTimeout(countdownId); countdownId = null; }

    // Clean up all persistence layers
    if (wakePingId) { clearInterval(wakePingId); wakePingId = null; }
    if (silentAudio) { silentAudio.pause(); silentAudio.src = ''; silentAudio = null; }
    if (silentOsc) { silentOsc.stop(); silentOsc = null; }
    if (audioCtx) { audioCtx.close(); audioCtx = null; }

    // Unlock settings
    settingsCard.style.opacity = '1';
    settingsCard.style.pointerEvents = 'auto';

    countdownEl.textContent = '--:--';
    phaseEl.textContent = 'å·²åœæ­¢';
    startBtn.textContent = 'â–¶  é–‹å§‹';
    startBtn.className = 'start-btn ready';

    log('ğŸ›‘ å·²åœæ­¢');
  }

  // â”€â”€â”€ Event binding â”€â”€â”€
  startBtn.addEventListener('click', () => {
    if (isRunning) {
      stopSession();
    } else {
      startSession();
    }
  });

  // â”€â”€â”€ Init â”€â”€â”€
  loadFileList();
})();
</script>
</body>
</html>
