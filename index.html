<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="Lucid Dreamer â€“ æ¸…é†’å¤¢èª˜ç™¼å·¥å…·">
<title>Lucid Dreamer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg-deep: #0a0a1a;
  --bg-card: rgba(255, 255, 255, 0.04);
  --border-glass: rgba(255, 255, 255, 0.08);
  --accent: #7c5cff;
  --accent-glow: rgba(124, 92, 255, 0.35);
  --accent-soft: #a78bfa;
  --text: #e4e4f0;
  --text-dim: #8888a8;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --radius: 16px;
  --font: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
}

html, body {
  height: 100%;
  font-family: var(--font);
  background: var(--bg-deep);
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  overflow-x: hidden;
}

body {
  background:
    radial-gradient(ellipse 80% 60% at 50% -10%, rgba(124, 92, 255, 0.15), transparent),
    radial-gradient(ellipse 50% 40% at 80% 90%, rgba(99, 102, 241, 0.1), transparent),
    var(--bg-deep);
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1.5rem 1rem 3rem;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
h1 {
  font-size: 1.75rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, #c4b5fd, #818cf8, #7c5cff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 0.25rem;
}
.subtitle { font-size: 0.8rem; color: var(--text-dim); font-weight: 300; margin-bottom: 1.5rem; }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Glass Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card {
  width: 100%;
  max-width: 420px;
  background: var(--bg-card);
  border: 1px solid var(--border-glass);
  border-radius: var(--radius);
  backdrop-filter: blur(24px);
  -webkit-backdrop-filter: blur(24px);
  padding: 1.5rem;
  margin-bottom: 1rem;
  transition: border-color 0.3s;
}
.card:hover { border-color: rgba(255,255,255,0.12); }

.card-title {
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-dim);
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.card-title::before {
  content: '';
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--accent);
  box-shadow: 0 0 8px var(--accent-glow);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.control-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.85rem;
}
.control-row:last-child { margin-bottom: 0; }

.control-label {
  font-size: 0.82rem;
  font-weight: 400;
  color: var(--text);
}
.control-label small {
  display: block;
  font-size: 0.68rem;
  color: var(--text-dim);
  font-weight: 300;
  margin-top: 2px;
}

input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 130px;
  height: 4px;
  border-radius: 2px;
  background: rgba(255,255,255,0.1);
  outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--accent);
  box-shadow: 0 0 10px var(--accent-glow);
  cursor: pointer;
}
.range-value {
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--accent-soft);
  min-width: 3rem;
  text-align: right;
  font-variant-numeric: tabular-nums;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Status Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.status-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.75rem;
}
.status-item {
  background: rgba(255,255,255,0.02);
  border: 1px solid var(--border-glass);
  border-radius: 12px;
  padding: 0.75rem;
  text-align: center;
}
.status-item.wide { grid-column: 1 / -1; }
.status-label {
  font-size: 0.65rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-dim);
  margin-bottom: 0.3rem;
}
.status-value {
  font-size: 1.4rem;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  color: var(--text);
}
.status-value.countdown {
  font-size: 2rem;
  background: linear-gradient(135deg, #c4b5fd, #7c5cff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Big Button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.start-btn {
  width: 100%;
  max-width: 420px;
  padding: 1rem;
  border: none;
  border-radius: var(--radius);
  font-family: var(--font);
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.04em;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  margin-top: 0.5rem;
}
.start-btn.ready {
  background: linear-gradient(135deg, #7c5cff, #6366f1);
  color: #fff;
  box-shadow: 0 4px 24px var(--accent-glow);
}
.start-btn.ready:active {
  transform: scale(0.97);
  box-shadow: 0 2px 12px var(--accent-glow);
}
.start-btn.running {
  background: linear-gradient(135deg, #ef4444, #dc2626);
  color: #fff;
  box-shadow: 0 4px 24px rgba(239, 68, 68, 0.3);
}
.start-btn.running:active { transform: scale(0.97); }

/* Pulse animation when active */
@keyframes pulse-ring {
  0% { transform: scale(1); opacity: 0.4; }
  100% { transform: scale(2.5); opacity: 0; }
}
.start-btn.running::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: var(--radius);
  border: 2px solid rgba(239, 68, 68, 0.5);
  animation: pulse-ring 2s ease-out infinite;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.log-area {
  width: 100%;
  max-width: 420px;
  max-height: 120px;
  overflow-y: auto;
  margin-top: 0.75rem;
  padding: 0.75rem;
  background: rgba(0,0,0,0.3);
  border: 1px solid var(--border-glass);
  border-radius: 12px;
  font-size: 0.7rem;
  color: var(--text-dim);
  line-height: 1.6;
  font-variant-numeric: tabular-nums;
}
.log-area .log-entry { margin-bottom: 2px; }
.log-area .log-entry.played { color: var(--success); }
.log-area .log-entry.skipped { color: var(--warning); }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Debug Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.debug-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 0.85rem;
  padding-top: 0.85rem;
  border-top: 1px solid var(--border-glass);
}
.debug-label {
  font-size: 0.82rem;
  font-weight: 400;
  color: var(--warning);
}
.debug-label small {
  display: block;
  font-size: 0.68rem;
  color: var(--text-dim);
  font-weight: 300;
  margin-top: 2px;
}
.toggle {
  position: relative;
  width: 44px;
  height: 24px;
  cursor: pointer;
}
.toggle input { opacity: 0; width: 0; height: 0; }
.toggle .slider {
  position: absolute;
  inset: 0;
  background: rgba(255,255,255,0.1);
  border-radius: 12px;
  transition: background 0.3s;
}
.toggle .slider::before {
  content: '';
  position: absolute;
  left: 3px; top: 3px;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: #fff;
  transition: transform 0.3s;
}
.toggle input:checked + .slider {
  background: var(--warning);
}
.toggle input:checked + .slider::before {
  transform: translateX(20px);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Scrollbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.footer {
  margin-top: auto;
  padding-top: 1.5rem;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.15);
  text-align: center;
}
</style>
</head>
<body>

<h1>ğŸŒ™ Lucid Dreamer</h1>
<p class="subtitle">æ¸…é†’å¤¢èª˜ç™¼å·¥å…· â€” PoC</p>

<!-- â”€â”€â”€ Settings â”€â”€â”€ -->
<div class="card" id="settings-card">
  <div class="card-title">è¨­å®š</div>

  <div class="control-row">
    <div class="control-label">å…¥ç¡ç·©è¡<small>é¦–æ¬¡è§¸ç™¼å‰çš„ç­‰å¾…æ™‚é–“</small></div>
    <input type="range" id="initial-delay" min="1" max="60" value="20" step="1">
    <span class="range-value" id="initial-delay-val">20 min</span>
  </div>

  <div class="control-row">
    <div class="control-label">æœ€å°é–“éš”<small>å¾ªç’°é–“æœ€çŸ­ç­‰å¾…</small></div>
    <input type="range" id="min-interval" min="1" max="30" value="5" step="1">
    <span class="range-value" id="min-interval-val">5 min</span>
  </div>

  <div class="control-row">
    <div class="control-label">æœ€å¤§é–“éš”<small>å¾ªç’°é–“æœ€é•·ç­‰å¾…</small></div>
    <input type="range" id="max-interval" min="2" max="60" value="15" step="1">
    <span class="range-value" id="max-interval-val">15 min</span>
  </div>

  <div class="control-row">
    <div class="control-label">éŸ³é‡ä¸Šé™<small>æ¼¸å¼·æœ€å¤§éŸ³é‡</small></div>
    <input type="range" id="volume-cap" min="5" max="100" value="40" step="5">
    <span class="range-value" id="volume-cap-val">40%</span>
  </div>

  <div class="control-row">
    <div class="control-label">è§¸ç™¼æ©Ÿç‡<small>æ¯æ¬¡å¾ªç’°æ’­æ”¾çš„æ©Ÿç‡</small></div>
    <input type="range" id="probability" min="10" max="100" value="30" step="5">
    <span class="range-value" id="probability-val">30%</span>
  </div>

  <div class="debug-row">
    <div class="debug-label">âš¡ Debug æ¨¡å¼<small>è·³éå»¶é²èˆ‡æ©Ÿç‡ï¼Œé€£çºŒæ’­æ”¾</small></div>
    <label class="toggle">
      <input type="checkbox" id="debug-mode">
      <span class="slider"></span>
    </label>
  </div>
</div>

<!-- â”€â”€â”€ Status â”€â”€â”€ -->
<div class="card">
  <div class="card-title">ç‹€æ…‹</div>
  <div class="status-grid">
    <div class="status-item wide">
      <div class="status-label">å€’æ•¸è¨ˆæ™‚</div>
      <div class="status-value countdown" id="countdown">--:--</div>
    </div>
    <div class="status-item">
      <div class="status-label">ç›®å‰éšæ®µ</div>
      <div class="status-value" id="phase" style="font-size:0.85rem;">å¾…æ©Ÿ</div>
    </div>
    <div class="status-item">
      <div class="status-label">å·²è§¸ç™¼</div>
      <div class="status-value" id="trigger-count">0</div>
    </div>
  </div>
</div>

<!-- â”€â”€â”€ Start Button â”€â”€â”€ -->
<button class="start-btn ready" id="start-btn">â–¶  é–‹å§‹</button>

<!-- â”€â”€â”€ Log â”€â”€â”€ -->
<div class="log-area" id="log-area">
  <div class="log-entry">ç­‰å¾…é–‹å§‹...</div>
</div>

<div class="footer">Lucid Dreamer PoC Â· GitHub Pages Edition</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Lucid Dreamer â€” iOS-optimized lucid dream induction engine
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(function () {
  'use strict';

  // â”€â”€â”€ DOM refs â”€â”€â”€
  const $ = id => document.getElementById(id);
  const startBtn       = $('start-btn');
  const countdownEl    = $('countdown');
  const phaseEl        = $('phase');
  const triggerCountEl = $('trigger-count');
  const logArea        = $('log-area');
  const settingsCard   = $('settings-card');

  // Sliders
  const sliders = {
    initialDelay: { el: $('initial-delay'), valEl: $('initial-delay-val'), fmt: v => `${v} min` },
    minInterval:  { el: $('min-interval'),  valEl: $('min-interval-val'),  fmt: v => `${v} min` },
    maxInterval:  { el: $('max-interval'),  valEl: $('max-interval-val'),  fmt: v => `${v} min` },
    volumeCap:    { el: $('volume-cap'),    valEl: $('volume-cap-val'),    fmt: v => `${v}%` },
    probability:  { el: $('probability'),   valEl: $('probability-val'),   fmt: v => `${v}%` },
  };

  // Sync slider display
  Object.values(sliders).forEach(s => {
    s.el.addEventListener('input', () => { s.valEl.textContent = s.fmt(s.el.value); });
  });

  // â”€â”€â”€ State â”€â”€â”€
  const debugToggle = $('debug-mode');
  let primaryAudio  = null;   // THE single <audio> element (keepalive + voice)
  let wakePingId    = null;   // Interval ID for periodic wake-up checks
  let fileList      = [];     // Array of filenames from filelist.json
  let isRunning     = false;
  let debugMode     = false;
  let isPlayingVoice = false; // true when primary audio is playing a voice track
  let triggerCount  = 0;
  let countdownId   = null;
  let targetTime    = 0;

  // â”€â”€â”€ Helpers â”€â”€â”€
  function getVal(key) { return Number(sliders[key].el.value); }

  function log(msg, cls = '') {
    const now = new Date();
    const ts = now.toLocaleTimeString('zh-TW', { hour12: false });
    const div = document.createElement('div');
    div.className = 'log-entry' + (cls ? ` ${cls}` : '');
    div.textContent = `[${ts}] ${msg}`;
    logArea.appendChild(div);
    logArea.scrollTop = logArea.scrollHeight;
  }

  function formatTime(ms) {
    if (ms <= 0) return '00:00';
    const totalSec = Math.ceil(ms / 1000);
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  }

  function randomInRange(minMin, maxMin) {
    // Returns ms for a random duration between minMin and maxMin minutes
    const lo = Math.min(minMin, maxMin);
    const hi = Math.max(minMin, maxMin);
    return (lo + Math.random() * (hi - lo)) * 60 * 1000;
  }

  // â”€â”€â”€ Load file list â”€â”€â”€
  async function loadFileList() {
    try {
      const res = await fetch('filelist.json');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      fileList = await res.json();
      // Filter out keepalive/silence from the voice pool
      fileList = fileList.filter(f => f !== 'silence.mp3' && f !== 'keepalive.mp3');
      log(`å·²è¼‰å…¥ ${fileList.length} å€‹éŸ³è¨Šæª”`);
    } catch (e) {
      log(`âš ï¸ ç„¡æ³•è¼‰å…¥ filelist.json: ${e.message}`);
      fileList = [];
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  iOS Background Persistence â€” Single Audio Element Strategy
  //
  //  KEY INSIGHT: iOS Safari suspends the web process when it detects
  //  loop gaps or considers audio "idle" (e.g. pure silence, short
  //  loops). A 2-second silent MP3 on loop gets killed quickly.
  //
  //  SOLUTION: Use ONE <audio> element for everything:
  //
  //  1. Plays keepalive.mp3 â€” a 10-minute near-inaudible 30Hz tone.
  //     Long duration = no loop gaps = iOS won't kill the session.
  //
  //  2. To play a voice prompt, we SWAP the src on this SAME element.
  //     iOS preserves the audio session because the element never
  //     "stops" â€” it transitions seamlessly.
  //
  //  3. After voice ends, we swap back to keepalive.mp3.
  //
  //  4. Media Session API registers us in Control Center and
  //     intercepts the pause button.
  //
  //  5. Periodic ping re-asserts playback if iOS paused us.
  //
  //  CRITICAL: Must be initiated from a user gesture (click).
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function startKeepAlive() {
    // Create the ONE audio element that stays alive for the entire session
    primaryAudio = new Audio('audio/keepalive.mp3');
    primaryAudio.loop = true;
    primaryAudio.volume = 0.01;
    primaryAudio.setAttribute('playsinline', '');
    primaryAudio.play().catch(() => {});
    isPlayingVoice = false;

    // â”€â”€ Media Session API â”€â”€
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: 'Lucid Dreamer',
        artist: 'æ¸…é†’å¤¢èª˜ç™¼ä¸­...',
        album: 'Sleep Session',
      });
      navigator.mediaSession.setActionHandler('play', () => {
        primaryAudio.play().catch(() => {});
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        // Refuse to pause â€” immediately resume
        primaryAudio.play().catch(() => {});
      });
    }

    // â”€â”€ Periodic wake-up (every 8s) â”€â”€
    wakePingId = setInterval(() => {
      if (primaryAudio && primaryAudio.paused && isRunning) {
        primaryAudio.play().catch(() => {});
      }
    }, 8000);

    // Resume on visibility change
    document.addEventListener('visibilitychange', () => {
      if (primaryAudio && primaryAudio.paused && isRunning) {
        primaryAudio.play().catch(() => {});
      }
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  Voice Playback â€” src-swap on the SAME <audio> element
  //
  //  Instead of new Audio(), we swap the src of primaryAudio.
  //  This preserves the iOS audio session. After voice ends,
  //  we swap back to keepalive.mp3.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function playRandomTrack() {
    if (!fileList.length || !primaryAudio) return Promise.resolve();

    const file = fileList[Math.floor(Math.random() * fileList.length)];
    const url = `audio/${file}`;

    return new Promise((resolve) => {
      isPlayingVoice = true;
      const volumeCap = getVal('volumeCap') / 100;

      // Swap src to voice track on the SAME element
      primaryAudio.loop = false;
      primaryAudio.volume = debugMode ? volumeCap : 0;
      primaryAudio.src = url;

      primaryAudio.play().then(() => {
        // JS-driven fade-in over 2 seconds
        if (!debugMode) {
          const steps = 40, stepMs = 50;
          const inc = volumeCap / steps;
          let s = 0;
          const fid = setInterval(() => {
            s++;
            if (primaryAudio) primaryAudio.volume = Math.min(inc * s, volumeCap);
            if (s >= steps) clearInterval(fid);
          }, stepMs);
        }
      }).catch((e) => {
        log(`âŒ æ’­æ”¾å¤±æ•—: ${e.message}`);
        switchBackToKeepalive();
        resolve();
      });

      primaryAudio.onended = () => {
        if (debugMode && isRunning) {
          setTimeout(() => playRandomTrack(), 500);
          resolve();
        } else {
          switchBackToKeepalive();
          resolve();
        }
      };

      primaryAudio.onerror = () => {
        log(`âŒ è¼‰å…¥å¤±æ•—: ${file}`);
        switchBackToKeepalive();
        resolve();
      };

      triggerCount++;
      triggerCountEl.textContent = triggerCount;
      log(`â–¶ æ’­æ”¾: ${file.slice(0, 8)}...`, 'played');
    });
  }

  function switchBackToKeepalive() {
    if (!primaryAudio) return;
    isPlayingVoice = false;
    primaryAudio.volume = 0.01;
    primaryAudio.loop = true;
    primaryAudio.src = 'audio/keepalive.mp3';
    primaryAudio.play().catch(() => {});
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  Countdown Timer
  //
  //  Uses a 1-second setTimeout loop instead of setInterval for
  //  better iOS compatibility. The countdown compares against a
  //  target timestamp so accumulated drift doesn't matter.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function startCountdown(durationMs, label, onComplete) {
    targetTime = Date.now() + durationMs;
    phaseEl.textContent = label;

    function tick() {
      if (!isRunning) return;
      const remaining = targetTime - Date.now();
      countdownEl.textContent = formatTime(remaining);

      if (remaining <= 0) {
        countdownEl.textContent = '00:00';
        onComplete();
      } else {
        countdownId = setTimeout(tick, 1000);
      }
    }
    tick();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  //  Main Loop â€” Randomized Scheduler with Probability Gate
  //
  //  After the initial delay, each cycle:
  //    1. Picks a random wait duration within [minInterval, maxInterval]
  //    2. Counts down the wait
  //    3. Rolls a probability check (e.g. 30%)
  //    4. If passed â†’ plays a random track with fade-in
  //    5. Repeats
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function scheduleCycle() {
    if (!isRunning) return;

    const waitMs = randomInRange(getVal('minInterval'), getVal('maxInterval'));
    const waitMin = (waitMs / 60000).toFixed(1);
    log(`â³ ä¸‹æ¬¡å¾ªç’°: ${waitMin} åˆ†é˜å¾Œ`);

    startCountdown(waitMs, 'ç­‰å¾…ä¸­', () => {
      if (!isRunning) return;

      const prob = getVal('probability') / 100;
      const roll = Math.random();

      if (roll < prob) {
        phaseEl.textContent = 'æ’­æ”¾ä¸­';
        playRandomTrack().then(() => {
          // Short pause after playback before next cycle
          setTimeout(() => { if (isRunning) scheduleCycle(); }, 3000);
        });
      } else {
        log(`â­ è·³é (æ©Ÿç‡ ${(roll * 100).toFixed(0)}% > ${getVal('probability')}%)`, 'skipped');
        scheduleCycle();
      }
    });
  }

  function startSession() {
    if (!fileList.length) {
      log('âš ï¸ æ²’æœ‰å¯ç”¨çš„éŸ³è¨Šæª”ï¼Œè«‹å…ˆç”Ÿæˆ filelist.json');
      return;
    }

    isRunning = true;
    debugMode = debugToggle.checked;
    triggerCount = 0;
    triggerCountEl.textContent = '0';

    // Start keepalive audio on user tap (iOS autoplay requirement)
    if (!primaryAudio) startKeepAlive();

    // Lock settings
    settingsCard.style.opacity = '0.5';
    settingsCard.style.pointerEvents = 'none';

    startBtn.textContent = 'â¹  åœæ­¢';
    startBtn.className = 'start-btn running';

    // â”€â”€â”€ Debug mode: skip everything, play immediately back-to-back â”€â”€â”€
    if (debugMode) {
      log('âš¡ Debug æ¨¡å¼ï¼šé€£çºŒéš¨æ©Ÿæ’­æ”¾ï¼Œç„¡å»¶é²');
      phaseEl.textContent = 'Debug';
      countdownEl.textContent = 'âš¡';
      playRandomTrack();
      return;
    }

    const delayMs = getVal('initialDelay') * 60 * 1000;
    log(`ğŸŒ™ é–‹å§‹! å…¥ç¡ç·©è¡: ${getVal('initialDelay')} åˆ†é˜`);

    startCountdown(delayMs, 'å…¥ç¡ç·©è¡', () => {
      log('â° ç·©è¡çµæŸï¼Œé–‹å§‹å¾ªç’°');
      scheduleCycle();
    });
  }

  function stopSession() {
    isRunning = false;
    if (countdownId) { clearTimeout(countdownId); countdownId = null; }

    // Clean up audio
    if (wakePingId) { clearInterval(wakePingId); wakePingId = null; }
    if (primaryAudio) { primaryAudio.pause(); primaryAudio.src = ''; primaryAudio = null; }
    isPlayingVoice = false;

    // Unlock settings
    settingsCard.style.opacity = '1';
    settingsCard.style.pointerEvents = 'auto';

    countdownEl.textContent = '--:--';
    phaseEl.textContent = 'å·²åœæ­¢';
    startBtn.textContent = 'â–¶  é–‹å§‹';
    startBtn.className = 'start-btn ready';

    log('ğŸ›‘ å·²åœæ­¢');
  }

  // â”€â”€â”€ Event binding â”€â”€â”€
  startBtn.addEventListener('click', () => {
    if (isRunning) {
      stopSession();
    } else {
      startSession();
    }
  });

  // â”€â”€â”€ Init â”€â”€â”€
  loadFileList();
})();
</script>
</body>
</html>
